#!/bin/bash
#set -x
set -e

isk8s=false
KUBECONFIG=""
K8S_NAMESPACE=""

### import seed-helpers.sh file with function definitions
source /hedge/hedge-scripts/seed-helpers.sh
MYFILE=$(basename "$0" .sh)

# Print usage if invalid arguments passed
usage() {
  echo -e "\n\tUsage: $0 [-k true/false (default:false)] [-c <KUBECONFIG_PATH>] [-n <K8S_NAMESPACE>]\n"
  return 1
}

# Parse command-line arguments
while getopts "k:c:n:" opt; do
  case "$opt" in
    k) isk8s="$OPTARG" ;;
    c) KUBECONFIG="$OPTARG" ;;
    n) K8S_NAMESPACE="$OPTARG" ;;
    *) usage ;;
  esac
done

if [ "$isk8s" = true ]; then
  if [ -z "$KUBECONFIG" ] || [ -z "$K8S_NAMESPACE" ]; then
    errlog "${LINENO}" "${MYFILE}" "KUBECONFIG and K8S_NAMESPACE must be set when -k is true (indicates Kubernetes env)"
    return 1
  fi
fi

#### Functions STARTS
# Fetch list of secrets from secrets.json
get_secrets_list() {
  # return all secrets and its description (except for vault - do not allow user to change the vault keys)
  descriptions_json=$(echo "$secrets_template_json" | jq -c --arg HEDGE_SECRETNAME_VAULT "$HEDGE_SECRETNAME_VAULT" \
      '[.secrets[] | select(.secretName != $HEDGE_SECRETNAME_VAULT) | {description: .description, secretName: .secretName}]')

  # Check if descriptions_json is empty
  if [ -z "$descriptions_json" ] || [ "$descriptions_json" = "[]" ]; then
    errlog "${LINENO}" "${MYFILE}" "No descriptions found in the secrets list."
    exit 1
  fi
}

update_bootstrap_step() {
  stepname=$1
  stepval=$2
  # Update the step value in bootstrap status file, and reset bootstrap done status to false
  updated_json=$(cat $HEDGE_BOOTSTRAP_STATUS_FILE | \
          jq --arg key "$stepname" --argjson value "$stepval" '.[$key] = $value' | \
          jq --arg HEDGE_BOOTSTRAP_COMPLETE "$HEDGE_BOOTSTRAP_COMPLETE" '.[$HEDGE_BOOTSTRAP_COMPLETE] = false')
  echo "$updated_json" > "$HEDGE_BOOTSTRAP_STATUS_FILE"
}

# Prompt user to change secret value(s) from selection
prompt_change_secret() {
  secret_name=$1
  secret_data=$2
  changed=false

  # Iterate over each key in secretData and prompt for overwrite
  secret_data_count=$(echo "$secret_data" | jq length)
  for i in $(seq 0 $((secret_data_count - 1))); do
    # Extract the key and current value for the current entry
    key=$(echo "$secret_data" | jq -r ".[$i].key")
    val=$(echo "$secret_data" | jq -r ".[$i].value")
    sensitive=$(echo "$secret_data" | jq -r ".[$i].sensitive // false") #defaults to false

    # Mqtt and Postgres passwords should be autogenerated
    case "$secret_name" in
      "$HEDGE_SECRETNAME_MQTT")
        if [ "$key" = "password" ]; then
          while true; do \
            echo -e "  $key (****):   [regenerate MQTT password? YES/NO]: \c" #\c to show user prompt in the same line
            read -r var
            if [ "$var" = "YES" ]; then
              echo "" #new line
              # Update mbconnection to false in hedge-bootstrap-status file
              update_bootstrap_step "$HEDGE_SECRETNAME_MQTT" false
              changed=true
              break
            elif [ "$var" = "NO" ]; then
              break
            else
              echo -e "Invalid input. Please enter YES or NO."
            fi
          done
          continue # fetch the next key
        fi
        ;;
      "$HEDGE_SECRETNAME_DB")
        if [ "$key" = "password" ]; then
          while true; do \
            echo -e "  $key (****):   [regenerate DB password? YES/NO]: \c" #\c to show user prompt in the same line
            read -r var
            if [ "$var" = "YES" ]; then
              echo "" #new line
              # get current pg password
              get_db_secret       # sets env PG_DB_PASSWORD
              current_password="$PG_DB_PASSWORD"
              # generate new password
              generate_db_secret  # sets env PG_DB_PASSWORD
              new_password="$PG_DB_PASSWORD"
              # update DB password
              if ! PGPASSWORD=$current_password psql -h hedge-db -U hedge -c "ALTER USER hedge WITH PASSWORD '$new_password';" > /dev/null; then
                errlog "${LINENO}" "${MYFILE}" "Failed to update database password"
                exit 1
              fi
              # Update dbconnection to false in hedge-bootstrap-status file
              #update_bootstrap_step "$HEDGE_SECRETNAME_DB" false
              changed=true
              break
            elif [ "$var" = "NO" ]; then
              break
            else
              echo -e "Invalid input. Please enter YES or NO."
            fi
          done
          continue # fetch the next key
        fi
        ;;
      "$HEDGE_SECRETNAME_CONSUL")
        if [ "$key" = "token" ]; then
          while true; do \
            echo -e "  $key (****):   [regenerate Consul token? YES/NO]: \c" #\c to show user prompt in the same line
            read -r var
            if [ "$var" = "YES" ]; then
              echo "" #new line

              # Revoke existing consul token before generating a new one
              validate_consul_token_file # sets HEDGE_CONSUL_TOKEN
              accessor_id=$(curl --header "X-Consul-Token: ${HEDGE_CONSUL_TOKEN}" \
                            http://"${CURRENT_HEDGE_NODE_SERVER_IP}:${STAGEGATE_REGISTRY_PORT}"/v1/acl/token/self 2>/dev/null | \
                            jq -r '.AccessorID')
              if [ -z "$accessor_id" ]; then
                errlog "${LINENO}" "${MYFILE}" "Failed to retrieve Accessor ID."
                exit 1
              fi
              MASTER_CONSUL_TOKEN=$(cat "${CONSUL_ACL_BOOTSTRAPTOKENPATH}" | jq -r '.SecretID')
              curl --request DELETE --header "X-Consul-Token: ${MASTER_CONSUL_TOKEN}" \
                   http://"${CURRENT_HEDGE_NODE_SERVER_IP}:${STAGEGATE_REGISTRY_PORT}/v1/acl/token/${accessor_id}" 2>/dev/null
              log "${LINENO}" "${MYFILE}" "Revoked old token. To generate a new token on next restart"

              # Update consulconnection to false in hedge-bootstrap-status file
              update_bootstrap_step "$HEDGE_SECRETNAME_CONSUL" false
              changed=true
              break
            elif [ "$var" = "NO" ]; then
              break
            else
              echo -e "Invalid input. Please enter YES or NO."
            fi
          done
          continue # fetch the next key
        fi
        ;;
      *)
        # pass through
        ;;
    esac

    # Display the prompt and wait for user input
    if $sensitive; then
      echo -e "  $key (****): \c" #\c to show user prompt in the same line
    else
      echo -e "  $key ($val): \c" #\c to show user prompt in the same line
    fi
    #echo -e "\033[1;34m$key\033[0m (\033[0;33m$val\033[0m): \c"
    read -r new_value

    # Use the current value if the user skips
    if [ -z "$new_value" ]; then
      new_value="$val"
    else
      changed=true
    fi

    # Update the value in the secretData array
    secret_data=$(echo "$secret_data" | jq -c --argjson index "$i" --arg value "$new_value" '.[$index].value = $value')
  done
  if ! $changed; then
    echo "" #new line
    log "${LINENO}" "${MYFILE}" "Nothing changed, Stop further execution.."
    exit 1
  fi
}

# Get list of secrets from secrets_template.json file
secrets_template_json=$(cat "/hedge/hedge-scripts/secrets/hedge_secrets_template.json")
get_secrets_list "$secrets_template_json"

# Display available options
echo "Available secrets:"
# Loop over descriptions and display them with index
seq=1
echo "$descriptions_json" | jq -c '.[]' | while IFS= read -r secret; do
  description=$(echo "$secret" | jq -r '.description')
  echo "  $seq. $description"
  seq=$((seq + 1))
done

len=$(echo "$descriptions_json" | jq 'length')
# Prompt the user to select a secret

echo -e "\n"
while true; do
  read -rp "Select the index to change its secrets (1-$len): " choice

  if ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -le 0 ] || [ "$choice" -gt "$len" ]; then
    echo "Invalid selection. Retry.."
    continue
  fi
  break
done

# Get the selected description (simulate array indexing)
index=$((choice - 1))
selected_secret=$(echo "$descriptions_json" | jq -c ".[$index]")

secret_name=$(echo "$selected_secret" | jq -r '.secretName')
description=$(echo "$selected_secret" | jq -r '.description')

echo -e "\nYou selected: $choice. $description ($secret_name)"

# Fetch existing secrets from Vault for this secretName (via hedge-admin API)
response=$(curl --header "Content-Type: application/json" --request GET "http://hedge-admin:48098/api/v3/secrets/$secret_name" -w "%{http_code}" -s)
if [ -z "$response" ]; then
  errlog "${LINENO}" "${MYFILE}" "No response received. The server might be down or unreachable."
  return 1
fi

status_code="${response: -3}"                # Extract the status code from response
# Check for curl connection failure (status_code is 000)
if [ "$status_code" = "000" ]; then
  errlog "${LINENO}" "${MYFILE}" "Unable to connect to the server. The server might be down or unreachable."
  return 1
fi
if [ "$status_code" -ne 200 ]; then
  errlog "${LINENO}" "${MYFILE}" "Curl request failed with status code $status_code."
  return 1
fi

secrets_json="${response%${status_code}}"    # Extract the response body - all but last 3 characters
if [ -z "$secrets_json" ]; then
  errlog "${LINENO}" "${MYFILE}" "Secrets json returned empty"
  return 1
fi

# transform secrets json from hedge-admin to the format expected by vault API:
#     Eg: {"key1":"val1","key2":"val2"}   >>
#         [{"key":"key1","value":"val1"},{"key":"key2","value":"val2"}}]
secret_data=$(echo "$secrets_json" | jq -c '[to_entries[] | {key: .key, value: .value}]')
if [ -z "$secret_data" ]; then
  errlog "${LINENO}" "${MYFILE}" "Failed transforming secrets json to Vault format"
  return 1
fi

echo -e "\nEditing secret values (Press Enter to skip overwriting a key):"

# Prompt user to allow changing secret values
prompt_change_secret "$secret_name" "$secret_data"

# Fetch content of hedge_admin_secrets.json since its already imported and scrubbed
imported_secrets_json=$(cat "/tmp/hedge-secrets/hedge_admin_secrets.json")
if [ -z "$imported_secrets_json" ]; then
  errlog "${LINENO}" "${MYFILE}" "Invalid secrets json: /tmp/hedge-secrets/hedge_admin_secrets.json"
  return 1
fi

# Update new secretData and set imported to false
new_secrets_json=$(echo "$imported_secrets_json" | \
                   jq -c --arg secret_name "$secret_name" --argjson secret_data "$secret_data" \
                   '.secrets |= map(if .secretName == $secret_name then .secretData = $secret_data | .imported = false else . end)')
#echo "$new_secrets_json"
if [ -z "$new_secrets_json" ]; then
  errlog "${LINENO}" "${MYFILE}" "Failed updating pre-imported secrets json with the new values"
  return 1
fi

# Backup all existing secrets per service, Remove hedge-bootstrap-done
secretsdir="/tmp/hedge-secrets"
dirname="backup.$(date +%Y%m%d).$(date +%s)"
mkdir "$secretsdir/$dirname"

# Move the service specific hedge_*secrets.json files and
# Copy other secret/status files: hedge-bootstrap-status, .mqcredhash, .pgpassword, .consultoken
log "${LINENO}" "${MYFILE}" "Backup current hedge-secrets and remove service specific secrets.json files"
rsync -a  --exclude='*/' "$secretsdir" "$secretsdir/$dirname/" || errlog "${LINENO}" "${MYFILE}" "Failed backing up hedge-secrets. Continue with failure"
rm -f "$secretsdir"/hedge_*secrets.json || errlog "${LINENO}" "${MYFILE}" "Failed cleaning up services specific hedge-*secrets.json files. Continue with failure"

# Create a new hedge_secrets.json with updated json
echo "$new_secrets_json" > "/tmp/hedge-secrets/hedge_secrets.json"

log "${LINENO}" "${MYFILE}" "Updated secrets have been saved." #\n $updated_json"
